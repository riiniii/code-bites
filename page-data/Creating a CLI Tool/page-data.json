{"componentChunkName":"component---src-templates-blog-post-js","path":"/Creating a CLI Tool/","result":{"data":{"site":{"siteMetadata":{"title":"Renee Huang"}},"markdownRemark":{"id":"91750db9-b65d-566c-8ced-cc7620b3b44b","excerpt":"I‚Äôve recently come across the need to create a script to generate seed data for a project. I wanted developers to be able to run this script by providing the‚Ä¶","html":"<p>I‚Äôve recently come across the need to create a script to generate seed data for a project. I wanted developers to be able to run this script by providing the tables they wanted to populate and a json file that had the details for each row of the table(s).</p>\n<p>While writing the script, I realized that I had no clue on best practices on how to write this CLI! I felt at the very basic level I could implement encapsulation - providing an easy to use CLI but not letting developers worry about the implementation details. I also wanted developers to be able to control certain settings through flags, but is there a well known interface (like <a href=\"https://www.redhat.com/en/topics/api/what-is-a-rest-api\">RESTful API</a> interfaces?) that I could use?</p>\n<p>The following writing contains my findings on best practices for designing a CLI.</p>\n<h3>The Basics</h3>\n<ol>\n<li>Use a command line parsing library when you can</li>\n<li>Return zero exit code on success, non-zero on failures.</li>\n<li>\n<p>Send output to stdout (or your equivalent in your environment)</p>\n<ol>\n<li>what‚Äôs the equivalent in javascript?</li>\n</ol>\n</li>\n<li>\n<p>Send messaging to stderr (so that log messaging, errors will all go to one place and not be fed to the next command)</p>\n<ol>\n<li>what‚Äôs the equivalent in javascript?</li>\n</ol>\n</li>\n<li>\n<p>when passed no options, -h, or the‚Äîhelp flag, return a description of what your program does, one or two examples of invocation, description of flags, and where to go for more information.</p>\n<ol>\n<li>don‚Äôt overload -h</li>\n<li>show most common flags</li>\n<li>use formatting in your help text</li>\n</ol>\n</li>\n</ol>\n<h3>General Tips</h3>\n<ol>\n<li>Show progress visually &#x26; in an easily readable way</li>\n<li>Create a reaction for every action</li>\n<li>Create human readable output (errors, action results, progress info, etc.), have a good signal-to-noise ratio</li>\n<li>Support your skim-readers - keep things succinct!</li>\n<li>Suggest next best step</li>\n<li>Consider your options and how you may suggest them for users who are missing some essential information</li>\n<li>Provide an easy way out</li>\n<li>\n<p>Flags over args</p>\n<ol>\n<li>have a full length version of all flags (ex. -h and ‚Äîhelp do the same things)</li>\n<li>see if you can use standard name for flags first</li>\n<li>make flag order independent if possible</li>\n<li>don‚Äôt put private data (like token) in flags</li>\n</ol>\n</li>\n<li>consider offering documentation, whether it be via the web, terminal-based, or <a href=\"https://en.wikipedia.org/wiki/Man_page\">man-pages</a></li>\n<li>never require a prompt - allow for everything to be done in one line via flags</li>\n<li>confirm with user before making a ‚Äúbig‚Äù change (ex. deleting a file, folder, or even an entire application)</li>\n<li>\n<p>on robustness,</p>\n<ol>\n<li>validate user input</li>\n<li>responsive is more important than fast</li>\n<li>show progress if something is taking a long time</li>\n<li>do stuff in parallel when you can, but be thoughtful about it</li>\n<li>make things time out</li>\n<li>make it idempotent</li>\n<li>make it crash only</li>\n<li>people will misuse your program üò¢</li>\n</ol>\n</li>\n<li>\n<p>future proofing your CLI</p>\n<ol>\n<li>make changes additive where you can (&#x26; ensure for backwards compatibility)</li>\n<li>warn before you make a non-additive change</li>\n<li>don‚Äôt allow arbitrary abbreviations of subcommands, it‚Äôll take up future wording that you might actually want to mean something</li>\n<li>don‚Äôt create a time bomb (aka don‚Äôt rely on external dependency where possible)</li>\n</ol>\n</li>\n</ol>\n<p>Great articles from where I got my information:</p>\n<ol>\n<li><a href=\"https://clig.dev/\">Command Line Interface Guidelines</a> - a must read</li>\n<li><a href=\"https://blog.developer.atlassian.com/10-design-principles-for-delightful-clis/\">10 Design Principles for delightful CLIs</a></li>\n<li><a href=\"https://devcenter.heroku.com/articles/cli-style-guide\">Heroku‚Äôs CLI Style Guide Specifics</a></li>\n<li><a href=\"https://medium.com/@jdxcode/12-factor-cli-apps-dd3c227a0e46\">12 Factors for CLI Apps</a></li>\n<li><a href=\"https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html\">POSIX Utility Conventions</a></li>\n</ol>","frontmatter":{"title":"Creating a CLI Tool","date":"November 08, 2021","description":"Notes on general guidelines for when you create a CLI tool."}}},"pageContext":{"slug":"/Creating a CLI Tool/","previous":{"fields":{"slug":"/Monorepo-vs-Polyrepo/"},"frontmatter":{"title":"Monorepo vs Polyrepo"}},"next":{"fields":{"slug":"/MVC vs MVT (React and Django)/"},"frontmatter":{"title":"MVC vs MVT (React and Django)"}}}},"staticQueryHashes":["1246554614","2841359383"]}